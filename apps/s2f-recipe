#!/usr/bin/env python

""" S2F recipe generation. """

import itertools
import logging

from collections import OrderedDict

import click
import lxml.etree as ET
import numpy as np
import yaml
import six

import bluepy

from connectome_tools.s2f_recipe import (
    BOUTON_REDUCTION_FACTOR,
    CV_SYNS_CONNECTION,
    MEAN_SYNS_CONNECTION,
    P_A,
    PMU_A,
    estimate_bouton_reduction,
    estimate_individual_bouton_reduction,
    estimate_syns_con,
    existing_recipe,
    experimental_syns_con,
    generalized_cv,
    override_mtype,
)
from connectome_tools.version import __version__


L = logging.getLogger('s2f-recipe')

REQUIRED_PARAMS = {
    BOUTON_REDUCTION_FACTOR,
}
# other required params (first choice)
ALTERNATIVE_PARAMS_1 = {
    P_A,
    PMU_A,
}
# other required params (second choice)
ALTERNATIVE_PARAMS_2 = {
    CV_SYNS_CONNECTION,
    MEAN_SYNS_CONNECTION,
}

DISPATCH = {
    'estimate_bouton_reduction': estimate_bouton_reduction,
    'estimate_individual_bouton_reduction': estimate_individual_bouton_reduction,
    'estimate_syns_con': estimate_syns_con,
    'experimental_syns_con': experimental_syns_con,
    'existing_recipe': existing_recipe,
    'generalized_cv': generalized_cv,
    'override_mtype': override_mtype,
}


def load_yaml(filepath):
    """ Load YAML file. """
    with open(filepath) as f:
        return yaml.safe_load(f)


def validate_params(pathway_dict):
    """Validate and potentially remove unwanted parameters for a given pathway dict.

    Args:
        pathway_dict (dict): dictionary of parameters.

    Returns:
        (bool, set):
            True if successful, False otherwise.
            Set of missing parameters, or None if no required parameters are missing.
    """
    if not REQUIRED_PARAMS.issubset(pathway_dict):
        # required parameters are incomplete
        return False, REQUIRED_PARAMS.difference(pathway_dict)
    elif ALTERNATIVE_PARAMS_1.issubset(pathway_dict):
        # alternative_1 parameters are complete
        for k in ALTERNATIVE_PARAMS_2:
            # remove the unwanted alternative_2 parameters if they exist
            pathway_dict.pop(k, None)
        return True, None
    elif ALTERNATIVE_PARAMS_1.intersection(pathway_dict):
        # alternative_1 parameters are present but incomplete
        return False, ALTERNATIVE_PARAMS_1.difference(pathway_dict)
    elif ALTERNATIVE_PARAMS_2.issubset(pathway_dict):
        # alternative_2 parameters are complete
        return True, None
    else:
        # alternative_2 parameters are incomplete
        return False, ALTERNATIVE_PARAMS_2.difference(pathway_dict)


def generate_recipe(circuit, strategies):
    """ Generate S2F recipe for `circuit` using `strategies`. """
    result = {}
    mtypes = sorted(circuit.cells.mtypes)

    for entry in strategies:
        assert len(entry) == 1
        strategy, kwargs = next(iter(entry.items()))
        L.info("Executing strategy '%s'...", strategy)
        strategy_result = DISPATCH[strategy].execute(circuit, **kwargs)
        for pathway_wildcard, params in six.iteritems(strategy_result):
            pathways = itertools.product(
                mtypes if pathway_wildcard[0] == '*' else [pathway_wildcard[0]],
                mtypes if pathway_wildcard[1] == '*' else [pathway_wildcard[1]]
            )
            for pathway in pathways:
                result.setdefault(pathway, {}).update(params)

    for pathway in itertools.product(mtypes, mtypes):
        if pathway not in result:
            L.warning("Undefined pathway: %s", pathway)
            continue
        is_valid, missing_params = validate_params(result[pathway])
        if not is_valid:
            L.warning(
                "pathway %s has undefined parameters: %s; skipping",
                pathway, ", ".join(missing_params)
            )
            del result[pathway]

    return result


def write_recipe(output_path, recipe, comment=None):
    """ Dump `recipe` as XML to `output_path`. """
    root = ET.Element('ConnectionRules')
    if comment is not None:
        root.addprevious(ET.Comment(comment))
    for pathway, params in sorted(recipe.items()):
        attr = OrderedDict()
        attr['from'] = pathway[0]
        attr['to'] = pathway[1]
        for param, value in six.iteritems(params):
            attr[param] = "{:.3f}".format(value)
        ET.SubElement(root, 'mTypeRule', attr)

    tree = ET.ElementTree(root)
    with open(output_path, 'wb') as f:
        tree.write(f, pretty_print=True, xml_declaration=True, encoding='utf-8')


@click.command()
@click.argument("circuit")
@click.option("-s", "--strategies", required=True, help="Path to strategies config")
@click.option("-v", "--verbose", count=True, help="-v for INFO, -vv for DEBUG")
@click.option("--seed", type=int, default=0, help="Pseudo-random generator seed", show_default=True)
@click.option("-o", "--output", required=True, help="Path to output file")
def app(circuit, strategies, verbose, seed, output):
    """ S2F recipe generation """
    logging.basicConfig(level=logging.WARN)
    L.setLevel({
        0: logging.WARN,
        1: logging.INFO,
        2: logging.DEBUG,
    }[verbose])

    strategies = load_yaml(strategies)

    comment = (
        "\nGenerated by s2f-recipe==%s" % __version__ +
        "\nfrom circuit %s" % circuit +
        "\nusing strategies (seed=%d):" % seed +
        "\n" + yaml.dump(strategies)
    )

    circuit = bluepy.Circuit(circuit).v2

    np.random.seed(seed)

    recipe = generate_recipe(circuit, strategies)
    write_recipe(output, recipe, comment=comment)


if __name__ == '__main__':
    app()  # pylint: disable=no-value-for-parameter
